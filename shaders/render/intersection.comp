#version 450
#extension GL_GOOGLE_include_directive : enable
#line 1 "./render/intersection.comp"


#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#line 1 "./render/../include/structs.glsl"
struct Minmax {
    vec4 mn;
    vec4 mx;
};

struct Thash {
    int triangle;
    int previous;
};

struct Voxel {
    int depthLeaf;
    int parent;
    int last;
    int suboff;
    int coord;
    int count;
    int _t0;
};

struct Ray {
    int idx;
    int prev;
    int texel;
    int actived;
    vec4 origin;
    vec4 direct;
    vec4 color;
    vec4 final;
    ivec4 params;
    ivec4 extended;
};

struct Hit {
    vec4 normal;
    vec4 tangent;
    vec2 texcoord;
    float dist;
    float _t0;
    int triangle;
    int materialID;
    int shaded;
    int _t2;
};

struct Texel {
    int last;
    int count;
    float x;
    float y;
};

struct Stride2f {
    float x;
    float y;
};

struct Stride3f {
    float x;
    float y;
    float z;
};

struct Stride3i {
    int x;
    int y;
    int z;
};

struct Stride4f {
    float x;
    float y;
    float z;
    float w;
};

vec2 toVec2(in Stride2f a){
    return vec2(a . x, a . y);
}

vec3 toVec3(in Stride3f a){
    return vec3(a . x, a . y, a . z);
}

vec4 toVec4(in Stride4f a){
    return vec4(a . x, a . y, a . z, a . w);
}

ivec3 toVec3(in Stride3i a){
    return ivec3(a . x, a . y, a . z);
}

Stride2f toStride2(in vec2 a){
    Stride2f o;
    o . x = a . x;
    o . y = a . y;
    return o;
}

Stride3f toStride3(in vec3 a){
    Stride3f o;
    o . x = a . x;
    o . y = a . y;
    o . z = a . z;
    return o;
}

Stride4f toStride4(in vec4 a){
    Stride4f o;
    o . x = a . x;
    o . y = a . y;
    o . z = a . z;
    o . w = a . w;
    return o;
}

struct bbox {
    vec4 pmin;
    vec4 pmax;
};

struct Leaf {
    bbox box;
    int parent;
    int _t0;
    int _t1;
    int _t2;
};

struct HlbvhNode {
    bbox box;
    ivec2 range;
    int parent;
    int left;
    int right;
    int _t0;
    int _t1;
    int _t2;
};
#line 7 "./render/intersection.comp"
#line 1 "./render/../include/constants.glsl"
const int LONGEST = 0xFFFFFFFF;
const float INFINITY = 100000.0f;
const float GAMMA = 1.0f;
const float PI = 3.1415926535897932384626422832795028841971f;
const float TWO_PI = 6.2831853071795864769252867665590057683943f;
const float SQRT_OF_ONE_THIRD = 0.5773502691896257645091487805019574556476f;
const float E = 2.7182818284590452353602874713526624977572f;


#line 8 "./render/intersection.comp"
#line 1 "./render/../include/uniforms.glsl"
struct RandomUniformStruct {
    float time;
};

struct MinmaxUniformStruct {
    int heap;
    float prec;
};

struct MaterialUniformStruct {
    int materialID;
    int doubleSide;
    float reflectivity;
    float dissolve;
    float illumPower;
    float ior;
};

struct SamplerUniformStruct {
    vec2 sceneRes;
    int samplecount;
    int rayCount;
    int iteration;
    int phase;
    int maxSamples;
    int currentSample;
    int maxFilters;
};

struct LightUniformStruct {
    vec4 lightVector;
    vec4 lightColor;
    float lightRadius;
    float lightDistance;
};

struct GeometryUniformStruct {
    mat4 transform;
    mat4 transformInv;
    vec4 colormod;
    float offset;

    int materialID;
    int triangleCount;
    int triangleOffset;
    int unindexed;
    int loadOffset;
    int NB_mode;
    int unk1;
};

struct HelperUniformStruct {
    ivec4 range;
};

struct OctreeUniformStruct {
    mat4 project;
    mat4 unproject;
    int maxDepth;
    int currentDepth;
    int nodeCount;
};

struct CameraUniformStruct {
    mat4 projInv;
    mat4 camInv;
    mat4 camInv2;
    vec4 eye;
    vec4 view;
    float prob;
    int enable360;
};

layout(std140, binding = 0)uniform ubo0 { RandomUniformStruct randomUniform;};
layout(std140, binding = 1)uniform ubo1 { MinmaxUniformStruct minmaxUniform;};
layout(std140, binding = 2)uniform ubo2 { MaterialUniformStruct materialUniform;};
layout(std140, binding = 3)uniform ubo3 { SamplerUniformStruct samplerUniform;};
layout(std140, binding = 4)uniform ubo4 { LightUniformStruct lightUniform;};
layout(std140, binding = 5)uniform ubo5 { GeometryUniformStruct geometryUniform;};
layout(std140, binding = 6)uniform ubo6 { HelperUniformStruct helperUniform;};
layout(std140, binding = 7)uniform ubo7 { OctreeUniformStruct octreeUniform;};
layout(std140, binding = 8)uniform ubo8 { CameraUniformStruct cameraUniform;};
#line 9 "./render/intersection.comp"
#line 1 "./render/../include/fast_math.glsl"
int pow2(in int d){
    return d <= 0 ? 1 :(2 <<(d - 1));
}

float pow2(in float d){
    return exp2(d);
}
#line 10 "./render/intersection.comp"
#line 1 "./render/../include/rays.glsl"
 layout(std430, binding = 8)buffer ssbo8 { Ray rays[];};
layout(std430, binding = 9)buffer ssbo9 { Hit hits[];};
layout(std430, binding = 10)buffer ssbo10 { Texel texelInfo[];};
layout(std430, binding = 13)buffer ssbo13 { int actived[];};
layout(std430, binding = 14)buffer ssbo14 { int qrays[];};
layout(binding = 0)uniform atomic_uint acounter;
layout(binding = 0, offset = 4)uniform atomic_uint rcounter;
layout(binding = 0, offset = 8)uniform atomic_uint qcounter;

void storeHit(in int hitIndex, inout Hit hit){
    hits[hitIndex]= hit;
}

void storeHit(inout Ray ray, inout Hit hit){
    storeHit(ray . idx, hit);
}

void storeRay(in int rayIndex, inout Ray ray){
    ray . idx = rayIndex;
    rays[rayIndex]= ray;
}

void storeRay(in Ray current, inout Ray ray){
    storeRay(current . prev, ray);
}

void storeRay(inout Ray ray){
    storeRay(ray . idx, ray);
}

void restoreRay(inout Ray ray){
    if(ray . actived < 1){
        ray . actived = 1;
        rays[ray . idx]= ray;
        uint act = atomicCounterIncrement(acounter);
        actived[act]= ray . idx;
    }
}

int createRayStrict(inout Ray original, in int idx, in int rayIndex){
    int prev = atomicExchange(texelInfo[idx]. last, rayIndex);
    atomicAdd(texelInfo[idx]. count, 1);

    Ray ray = original;
    ray . idx = rayIndex;
    ray . prev = prev;
    ray . texel = idx;

    Hit hit;
    if(original . idx != LONGEST){
        hit = hits[original . idx];
    } else {
        hit . triangle = LONGEST;
        hit . normal = vec4(0.0f);
        hit . tangent = vec4(0.0f);
        hit . materialID = LONGEST;
        hit . dist = INFINITY;
        hit . shaded = 0;
    }

    hits[rayIndex]= hit;
    rays[rayIndex]= ray;

    if(ray . actived > 0){
        uint act = atomicCounterIncrement(acounter);
        actived[act]= rayIndex;

    }
    return rayIndex;
}

int createRayStrict(inout Ray original, in int rayIndex){
    return createRayStrict(original, original . texel, rayIndex);
}

int createRayAccount(inout Ray original, in int idx, in int rayIndex){
    atomicCounterIncrement(rcounter);
    return createRayStrict(original, idx, rayIndex);
}

int createRay(inout Ray original, in int idx){
    int rayIndex = int(atomicCounterIncrement(rcounter));
    return createRayStrict(original, idx, rayIndex);
}

int createRay(in Ray original){
    return createRay(original, original . texel);
}

int createRay(in int idx){
    Ray newRay;
    return createRay(newRay, idx);
}

Ray fetchRayDirect(in int texel){
    return rays[texel];
}

Hit fetchHitDirect(in int texel){
    return hits[texel];
}

int fetchRayIdx(in int texel){
    return texelInfo[texel]. last;
}

int fetchHitIdx(in int texel){
    return texelInfo[texel]. last;
}

Ray fetchRay(in int texel){
    return fetchRayDirect(fetchRayIdx(texel));
}

Hit fetchHit(in int texel){
    return fetchHitDirect(fetchHitIdx(texel));
}

Hit fetchHit(in Ray ray){
    return hits[ray . idx];
}

Ray nextRay(in Ray ray){
    return rays[ray . prev];
}

int getRayCount(in int texel){
    return texelInfo[texel]. count;
}

bool haveChain(in Ray ray){
    return ray . prev != LONGEST;
}
#line 11 "./render/intersection.comp"
#line 1 "./render/../include/vertex.glsl"
 layout(std430, binding = 3)buffer ssbo3 { Stride3f verts[];};
layout(std430, binding = 4)buffer ssbo4 { int indics[];};
layout(std430, binding = 5)buffer ssbo5 { Stride3f norms[];};
layout(std430, binding = 6)buffer ssbo6 { Stride2f texcs[];};
layout(std430, binding = 7)buffer ssbo7 { int mats[];};
#line 12 "./render/intersection.comp"
#line 1 "./render/../include/morton.glsl"
int part1By2_64(in int a){
    int x = a & 0x000003ff;
    x =(x |(x << 16))& 0xff0000ff;
    x =(x |(x << 8))& 0x0300f00f;
    x =(x |(x << 4))& 0x030c30c3;
    x =(x |(x << 2))& 0x09249249;
    return x;
}

int encodeMorton3_64(in ivec3 a)
{
    return part1By2_64(a . x)|(part1By2_64(a . y)<< 1)|(part1By2_64(a . z)<< 2);
}

int compact1By2_64(in int a)
{
    int x = a & 0x09249249;
    x =(x |(x >> 2))& 0x030c30c3;
    x =(x |(x >> 4))& 0x0300f00f;
    x =(x |(x >> 8))& 0xff0000ff;
    x =(x |(x >> 16))& 0x000003ff;
    return x;
}

ivec3 decodeMorton3_64(in int code)
{
    return ivec3(compact1By2_64(code >> 0), compact1By2_64(code >> 1), compact1By2_64(code >> 2));
}

ivec2 decodeDepthLeaf(int dl){
    return ivec2((dl >> 31)& 1, dl & 0x7FFFFFFF);
}

int encodeDepthLeaf(ivec2 dl){
    return((dl . x & 1)<< 31)|(dl . y & 0x7FFFFFFF);
}
#line 13 "./render/intersection.comp"

vec2 intersectCube(in vec3 origin, in vec3 ray, in vec3 cubeMin, in vec3 cubeMax){
    vec3 dr = vec3(1.0f)/ ray;
    vec3 tMin =(cubeMin - origin)* dr;
    vec3 tMax =(cubeMax - origin)* dr;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1 . x, t1 . y), t1 . z);
    float tFar = min(min(t2 . x, t2 . y), t2 . z);
    vec2 dsts = vec2(INFINITY);
    if(tFar > tNear && tFar >= 0.0f && tNear < INFINITY){
        dsts = vec2(tNear, tFar);
    }
    return dsts;
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax){
    vec4 norm = vec4(0.0f);
    if(hit . x < cubeMin . x + 0.0001f){ norm += vec4(- 1.0f, 0.0f, 0.0f, 1.0f);}
    if(hit . x > cubeMax . x - 0.0001f){ norm += vec4(1.0f, 0.0f, 0.0f, 1.0f);}
    if(hit . y < cubeMin . y + 0.0001f){ norm += vec4(0.0f, - 1.0f, 0.0f, 1.0f);}
    if(hit . y > cubeMax . y - 0.0001f){ norm += vec4(0.0f, 1.0f, 0.0f, 1.0f);}
    if(hit . z < cubeMin . z + 0.0001f){ norm += vec4(0.0f, 0.0f, - 1.0f, 1.0f);}
    if(hit . z > cubeMax . z - 0.0001f){ norm += vec4(0.0f, 0.0f, 1.0f, 1.0f);}
    return normalize(norm . xyz / norm . w);
}

float intersectTriangle(in vec3 orig, in vec3 dir, inout vec3 ve[3], inout vec2 UV, inout vec3 norm){
    vec3 e1 = vec3(ve[1]- ve[0]);
    vec3 e2 = vec3(ve[2]- ve[0]);
    vec3 dirc = vec3(dir);
    vec3 origc = vec3(orig);

    vec3 p = - cross(dirc, e2);
    float det = dot(e1, p);
    if(abs(det)< 0.0000001f)return INFINITY;

    vec3 n = normalize(cross(e1, e2));
    float ls = dot(dirc, n);
    if(abs(ls)< 0.0000001f)return INFINITY;

    vec3 T = origc - vec3(ve[0]);
    float pt = dot(T, n)/ ls;
    if(pt > 0.0f)return INFINITY;

    float idet = 1.0f / det;
    float u = dot(T, p)* idet;
    if(u < 0.0f || u > 1.0f)return INFINITY;

    vec3 q = - cross(T, e1);
    float v = dot(dirc, q)* idet;
    if(v < 0.0f ||(u + v)> 1.0f)return INFINITY;

    float t = dot(e2, q)* idet;
    if(t >= 0.0f){
        UV . x = u;
        UV . y = v;
        norm = n;
        return t;
    }

    return INFINITY;
}

struct TResult {
    float dist;
    int triangle;
    int materialID;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    vec2 uv;
};

TResult loadInfo(inout TResult res){
    const vec2 barys[3]= { vec2(0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f)};

    int tri = res . triangle;
    if(res . dist >= 0.0f && res . dist < INFINITY && tri != LONGEST){
        vec3 trinorms[3];
        vec3 triverts[3];
        vec2 texcoords[3];

        for(int x = 0;x < 3;x ++){
            int j = indics[tri * 3 + x];
            triverts[x]= toVec3(verts[j]);
            trinorms[x]= toVec3(norms[j]);
            texcoords[x]= toVec2(texcs[j]);

        }

        vec2 uv = res . uv;
        vec3 nor = res . normal;
        vec3 normal = fma(trinorms[0], vec3(1.0f - uv . x - uv . y), fma(trinorms[1], vec3(uv . x), trinorms[2]* vec3(uv . y)));

        if(length(normal)< 0.0001f){
            normal = nor;
        } else {
            normal = normalize(normal);
            normal = faceforward(normal, nor, - normal);
        }

        vec2 texcoord = fma(texcoords[0], vec2(1.0f - uv . x - uv . y), fma(texcoords[1], vec2(uv . x), texcoords[2]* vec2(uv . y)));
        vec3 deltaPos1 = triverts[1]- triverts[0];
        vec3 deltaPos2 = triverts[2]- triverts[0];
        vec2 deltaUV1 = texcoords[1]- texcoords[0];
        vec2 deltaUV2 = texcoords[2]- texcoords[0];

        if(all(equal(texcoords[0], texcoords[1]))&& all(equal(texcoords[0], texcoords[2]))){
            deltaUV1 = vec2(1.0f, 0.0f);
            deltaUV2 = vec2(0.0f, 1.0f);
        }

        float f = 1.0f / fma(deltaUV1 . x, deltaUV2 . y, - deltaUV1 . y * deltaUV2 . x);
        vec3 tan = fma(deltaPos1, vec3(deltaUV2 . y), - deltaPos2 * deltaUV1 . y)* f;

        res . normal = normal;
        res . texcoord = texcoord;
        res . materialID = mats[tri];
        res . tangent = normalize(tan - faceforward(normal, tan, - normal));
    }

    return res;
}


TResult traverseDirectly(in float distn, in vec3 origin, in vec3 direct){
    TResult lastRes;
    lastRes . triangle = LONGEST;
    lastRes . dist = distn;
    lastRes . materialID = LONGEST;

    for(int i = 0;i < 10000;i ++){
        if(i >= geometryUniform . triangleCount)break;

        int tri = i;
        vec3 triverts[3];
        for(int x = 0;x < 3;x ++){
            int j = indics[tri * 3 + x];
            triverts[x]= toVec3(verts[j]);
        }
        vec2 uv = vec2(0.0f);
        vec3 n = vec3(0.0f);
        float _d = intersectTriangle(origin, direct, triverts, uv, n);

        if(_d < INFINITY && _d >= 0.0f && _d <= lastRes . dist){
            lastRes . dist = _d;
            lastRes . triangle = tri;
            lastRes . uv = uv;
            lastRes . normal = n;
        }

        if(lastRes . dist <= 0.0f)break;
    }

    return loadInfo(lastRes);
}


#line 1 "./render/../hlbvh/traverse.glsl"
 layout(std430, binding = 0)buffer NodesBlock { HlbvhNode Nodes[];};
layout(std430, binding = 1)buffer MortoncodesBlock { ivec2 Mortoncodes[];};



TResult testIntersection(inout TResult res, in vec3 orig, in vec3 dir, in int tri){
    if(tri != LONGEST && res . triangle != tri && tri >= 0 && tri < geometryUniform . triangleCount){
        vec3 triverts[3];
        for(int x = 0;x < 3;x ++){
            int j = indics[tri * 3 + x];
            triverts[x]= toVec3(verts[j]);
        }
        vec2 uv = vec2(0.0f);
        vec3 n = vec3(0.0f);
        float _d = intersectTriangle(orig, dir, triverts, uv, n);
        if(_d < INFINITY && _d >= 0.0f && _d <= res . dist){
            res . dist = _d;
            res . triangle = tri;
            res . uv = uv;
            res . normal = n;
        }
    }
    return res;
}

vec3 projectVoxels(in vec3 orig){
    return(octreeUniform . project * vec4(orig, 1.0f)). xyz;
}

vec3 unprojectVoxels(in vec3 orig){
    return(inverse(octreeUniform . project)* vec4(orig, 1.0f)). xyz;
}

float intersectCubeSingle(in vec3 origin, in vec3 ray, in vec3 cubeMin, in vec3 cubeMax, inout float near){
    vec3 dr = vec3(1.0f)/ ray;
    vec3 tMin =(cubeMin - origin)* dr;
    vec3 tMax =(cubeMax - origin)* dr;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1 . x, t1 . y), t1 . z);
    float tFar = min(min(t2 . x, t2 . y), t2 . z);
    float t =(tFar > tNear && tFar > 0.f)?(tNear > 0.f ? min(tNear, tFar): max(tNear, tFar)): INFINITY;
    near =(tFar > tNear)? max(tNear, 0.f): INFINITY;
    return t > 0.f ? t : INFINITY;
}

const float precerr = 0.0001f;




const int leftMask = 1;
const int rightMask = 2;
const int leftNearMask = 4;
const int unknownMask = 8;

bool ism(in int bits, in int mask){
    return bits >= 0 ?((bits & mask)> 0): false;
}

const int STACK_SIZE = 24;
shared int stack[64][24];


TResult traverse(in float distn, in vec3 origin, in vec3 direct){
    TResult lastRes;
    lastRes . triangle = LONGEST;
    lastRes . dist = distn;
    lastRes . materialID = LONGEST;

    vec3 torig = projectVoxels(origin);
    vec3 dirproj =(vec4(direct, 0.0)* octreeUniform . project). xyz;
    float dirlen = length(direct)/ length(dirproj);
    dirproj = normalize(dirproj);
    float near = 0.0f;
    float d = intersectCubeSingle(torig, dirproj, vec3(0.0f), vec3(1.0f), near);
    float dst = near * dirlen;

    const uint l = gl_LocalInvocationID . x;
    float prevd = lastRes . dist;


    if(
        (d > 0.0f && d < INFINITY)&&
        (lastRes . dist > 0.0f)&&
        (lastRes . dist >= dst)
    ){
        int ptr = 0;
        stack[l][ptr]= - 1;

        HlbvhNode node;
        int idx = 0;

        for(int i = 0;i < 4096;i ++){
            if(lastRes . dist <= 0.0f)break;
            node = Nodes[idx];

            if((((node). left)==((node). right))){
                prevd = lastRes . dist;
                testIntersection(lastRes, origin, direct, Mortoncodes[node . left]. x);
                if(lastRes . dist <= 0.0f)break;
            } else {

                bool selfOverlap = prevd <= lastRes . dist ? true : false;
                float selfhit = 0.0f;
                if(! selfOverlap){
                    float near = 0.0f;
                    bbox lbox = node . box;
                    selfhit = intersectCubeSingle(torig, dirproj, lbox . pmin . xyz, lbox . pmax . xyz, near);
                    float dst = near * dirlen;
                    selfOverlap =(selfhit < INFINITY && selfhit > 0.0f)&&(dst <= lastRes . dist);
                }

                bool leftOverlap = false;
                float lefthit = 0.0f;
                if(selfOverlap){
                    float near = 0.0f;
                    bbox lbox = Nodes[node . left]. box;
                    lefthit = intersectCubeSingle(torig, dirproj, lbox . pmin . xyz, lbox . pmax . xyz, near);
                    float dst = near * dirlen;
                    leftOverlap =(lefthit < INFINITY && lefthit > 0.0f)&&(dst <= lastRes . dist);
                }

                bool rightOverlap = false;
                float righthit = 0.0f;
                if(selfOverlap){
                    float near = 0.0f;
                    bbox rbox = Nodes[node . right]. box;
                    righthit = intersectCubeSingle(torig, dirproj, rbox . pmin . xyz, rbox . pmax . xyz, near);
                    float dst = near * dirlen;
                    rightOverlap =(righthit < INFINITY && righthit > 0.0f)&&(dst <= lastRes . dist);
                }

                if(leftOverlap && rightOverlap){
                    bool leftNear = lefthit <= righthit;
                    if(ptr < STACK_SIZE){
                        stack[l][ptr ++]= leftNear ? node . right : node . left;
                    }
                    idx = leftNear ? node . left : node . right;
                    continue;
                } else
                if(leftOverlap || rightOverlap){
                    idx = leftOverlap ? node . left : node . right;
                    continue;
                }

            }

            {
                int pt = -- ptr;
                if(pt >= 0 && pt < STACK_SIZE){
                    idx = stack[l][pt];
                    stack[l][pt]= - 1;
                }
                if(idx < 0 || pt < 0)break;
            }
        }
    }
    return loadInfo(lastRes);
}
#line 173 "./render/intersection.comp"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1)in;


uniform int directTraverse;




void main(){
    int offT = int(gl_GlobalInvocationID . x);
    int it = offT;
    if(it >= samplerUniform . rayCount)return;

    int t = actived[it];
    Ray ray = fetchRayDirect(t);
    if(ray . actived < 1)return;

    Hit hit = fetchHitDirect(t);
    TResult res;

    if(directTraverse > 0){
        res = traverseDirectly(hit . dist, ray . origin . xyz, ray . direct . xyz);
    } else {
        res = traverse(hit . dist, ray . origin . xyz, ray . direct . xyz);
    }

    if(
        res . dist >= 0.0f &&
        res . dist < INFINITY &&
        res . triangle != LONGEST &&
        res . dist <= hit . dist &&
        res . materialID >= 0 &&
        res . materialID != LONGEST
    ){
        Hit newHit = hit;
        newHit . shaded = 0;
        newHit . dist = res . dist;
        newHit . normal . xyz = res . normal;
        newHit . triangle = res . triangle;
        newHit . materialID = res . materialID;
        newHit . texcoord . xy = res . texcoord;
        newHit . tangent . xyz = res . tangent;
        storeHit(t, newHit);
    }
}
