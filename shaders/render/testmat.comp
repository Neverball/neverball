#version 450
#extension GL_GOOGLE_include_directive : enable
#line 1 "./render/testmat.comp"


#extension GL_ARB_gpu_shader_int64 : require
#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require
#extension GL_ARB_bindless_texture : require

#line 1 "./render/../include/structs.glsl"
struct Minmax {
    vec4 mn;
    vec4 mx;
};

struct Thash {
    int triangle;
    int previous;
};

struct Voxel {
    int depthLeaf;
    int parent;
    int last;
    int suboff;
    int coord;
    int count;
    int _t0;
};

struct Ray {
    int idx;
    int prev;
    int texel;
    int actived;
    vec4 origin;
    vec4 direct;
    vec4 color;
    vec4 final;
    ivec4 params;
    ivec4 extended;
};

struct Hit {
    vec4 normal;
    vec4 tangent;
    vec4 color;
    vec2 texcoord;
    float dist;
    float _t0;
    int triangle;
    int materialID;
    int shaded;
    int _t2;
};

struct Texel {
    int last;
    int count;
    float x;
    float y;
};

struct Stride2f {
    float x;
    float y;
};

struct Stride3f {
    float x;
    float y;
    float z;
};

struct Stride3i {
    int x;
    int y;
    int z;
};

struct Stride4f {
    float x;
    float y;
    float z;
    float w;
};

vec2 toVec2(in Stride2f a){
    return vec2(a . x, a . y);
}

vec3 toVec3(in Stride3f a){
    return vec3(a . x, a . y, a . z);
}

vec4 toVec4(in Stride4f a){
    return vec4(a . x, a . y, a . z, a . w);
}

ivec3 toVec3(in Stride3i a){
    return ivec3(a . x, a . y, a . z);
}

Stride2f toStride2(in vec2 a){
    Stride2f o;
    o . x = a . x;
    o . y = a . y;
    return o;
}

Stride3f toStride3(in vec3 a){
    Stride3f o;
    o . x = a . x;
    o . y = a . y;
    o . z = a . z;
    return o;
}

Stride4f toStride4(in vec4 a){
    Stride4f o;
    o . x = a . x;
    o . y = a . y;
    o . z = a . z;
    o . w = a . w;
    return o;
}

struct bbox {
    vec4 pmin;
    vec4 pmax;
};

struct Leaf {
    bbox box;
    int parent;
    int _t0;
    int _t1;
    int _t2;
};

struct HlbvhNode {
    bbox box;
    ivec2 range;
    int parent;
    int left;
    int right;
    int _t0;
    int _t1;
    int _t2;
};
#line 9 "./render/testmat.comp"
#line 1 "./render/../include/constants.glsl"
const int LONGEST = 0xFFFFFFFF;
const float INFINITY = 10000.0f;
const float GAMMA = 1.0f;
const float PI = 3.1415926535897932384626422832795028841971f;
const float TWO_PI = 6.2831853071795864769252867665590057683943f;
const float SQRT_OF_ONE_THIRD = 0.5773502691896257645091487805019574556476f;
const float E = 2.7182818284590452353602874713526624977572f;


#line 10 "./render/testmat.comp"
#line 1 "./render/../include/uniforms.glsl"
struct RandomUniformStruct {
    float time;
};

struct MinmaxUniformStruct {
    int heap;
    float prec;
};

struct MaterialUniformStruct {
    int materialID;
    int doubleSide;
    float reflectivity;
    float dissolve;
    float illumPower;
    float ior;
};

struct SamplerUniformStruct {
    vec2 sceneRes;
    int samplecount;
    int rayCount;
    int iteration;
    int phase;
    int maxSamples;
    int currentSample;
    int maxFilters;
};

struct LightUniformStruct {
    vec4 lightVector;
    vec4 lightColor;
    float lightRadius;
    float lightDistance;
};

struct GeometryUniformStruct {
    mat4 transform;
    mat4 transformInv;
    vec4 colormod;
    float offset;

    int materialID;
    int triangleCount;
    int triangleOffset;
    int unindexed;
    int loadOffset;
    int NB_mode;
    int unk1;
};

struct HelperUniformStruct {
    ivec4 range;
};

struct OctreeUniformStruct {
    mat4 project;
    mat4 unproject;
    int maxDepth;
    int currentDepth;
    int nodeCount;
};

struct CameraUniformStruct {
    mat4 projInv;
    mat4 camInv;
    mat4 camInv2;
    vec4 eye;
    vec4 view;
    float prob;
    int enable360;
};

layout(std140, binding = 0)uniform ubo0 { RandomUniformStruct randomUniform;};
layout(std140, binding = 1)uniform ubo1 { MinmaxUniformStruct minmaxUniform;};
layout(std140, binding = 2)uniform ubo2 { MaterialUniformStruct materialUniform;};
layout(std140, binding = 3)uniform ubo3 { SamplerUniformStruct samplerUniform;};
layout(std140, binding = 4)uniform ubo4 { LightUniformStruct lightUniform;};
layout(std140, binding = 5)uniform ubo5 { GeometryUniformStruct geometryUniform;};
layout(std140, binding = 6)uniform ubo6 { HelperUniformStruct helperUniform;};
layout(std140, binding = 7)uniform ubo7 { OctreeUniformStruct octreeUniform;};
layout(std140, binding = 8)uniform ubo8 { CameraUniformStruct cameraUniform;};
#line 11 "./render/testmat.comp"
#line 1 "./render/../include/fast_math.glsl"
int pow2(in int d){
    return d <= 0 ? 1 :(2 <<(d - 1));
}

float pow2(in float d){
    return exp2(d);
}
#line 12 "./render/testmat.comp"
#line 1 "./render/../include/rays.glsl"
 layout(std430, binding = 8)buffer ssbo8 { Ray rays[];};
layout(std430, binding = 9)buffer ssbo9 { Hit hits[];};
layout(std430, binding = 10)buffer ssbo10 { Texel texelInfo[];};
layout(std430, binding = 13)buffer ssbo13 { int actived[];};
layout(std430, binding = 14)buffer ssbo14 { int qrays[];};
layout(binding = 0)uniform atomic_uint acounter;
layout(binding = 0, offset = 4)uniform atomic_uint rcounter;
layout(binding = 0, offset = 8)uniform atomic_uint qcounter;

void storeHit(in int hitIndex, inout Hit hit){
    hits[hitIndex]= hit;
}

void storeHit(inout Ray ray, inout Hit hit){
    storeHit(ray . idx, hit);
}

void storeRay(in int rayIndex, inout Ray ray){
    ray . idx = rayIndex;
    rays[rayIndex]= ray;
}

void storeRay(in Ray current, inout Ray ray){
    storeRay(current . prev, ray);
}

void storeRay(inout Ray ray){
    storeRay(ray . idx, ray);
}

void restoreRay(inout Ray ray){
    if(ray . actived < 1){
        ray . actived = 1;
        rays[ray . idx]= ray;
        uint act = atomicCounterIncrement(acounter);
        actived[act]= ray . idx;
    }
}

int createRayStrict(inout Ray original, in int idx, in int rayIndex){
    int prev = atomicExchange(texelInfo[idx]. last, rayIndex);
    atomicAdd(texelInfo[idx]. count, 1);

    Ray ray = original;
    ray . idx = rayIndex;
    ray . prev = prev;
    ray . texel = idx;

    Hit hit;
    if(original . idx != LONGEST){
        hit = hits[original . idx];
    } else {
        hit . triangle = LONGEST;
        hit . normal = vec4(0.0f);
        hit . tangent = vec4(0.0f);
        hit . materialID = LONGEST;
        hit . dist = INFINITY;
        hit . shaded = 0;
    }

    hits[rayIndex]= hit;
    rays[rayIndex]= ray;

    if(ray . actived > 0){
        uint act = atomicCounterIncrement(acounter);
        actived[act]= rayIndex;

    }
    return rayIndex;
}

int createRayStrict(inout Ray original, in int rayIndex){
    return createRayStrict(original, original . texel, rayIndex);
}

int createRayAccount(inout Ray original, in int idx, in int rayIndex){
    atomicCounterIncrement(rcounter);
    return createRayStrict(original, idx, rayIndex);
}

int createRay(inout Ray original, in int idx){
    int rayIndex = int(atomicCounterIncrement(rcounter));
    return createRayStrict(original, idx, rayIndex);
}

int createRay(in Ray original){
    return createRay(original, original . texel);
}

int createRay(in int idx){
    Ray newRay;
    return createRay(newRay, idx);
}

Ray fetchRayDirect(in int texel){
    return rays[texel];
}

Hit fetchHitDirect(in int texel){
    return hits[texel];
}

int fetchRayIdx(in int texel){
    return texelInfo[texel]. last;
}

int fetchHitIdx(in int texel){
    return texelInfo[texel]. last;
}

Ray fetchRay(in int texel){
    return fetchRayDirect(fetchRayIdx(texel));
}

Hit fetchHit(in int texel){
    return fetchHitDirect(fetchHitIdx(texel));
}

Hit fetchHit(in Ray ray){
    return hits[ray . idx];
}

Ray nextRay(in Ray ray){
    return rays[ray . prev];
}

int getRayCount(in int texel){
    return texelInfo[texel]. count;
}

bool haveChain(in Ray ray){
    return ray . prev != LONGEST;
}
#line 13 "./render/testmat.comp"
#line 1 "./render/../include/random.glsl"
 float counter = 0.0f;
int globalInvocationSMP = 0;

int hash(int x){
    x +=(x << 10);
    x ^=(x >> 6);
    x +=(x << 3);
    x ^=(x >> 11);
    x +=(x << 15);
    return x;
}

int hash(ivec2 v){ return hash(v . x ^ hash(v . y));}
int hash(ivec3 v){ return hash(v . x ^ hash(v . y)^ hash(v . z));}
int hash(ivec4 v){ return hash(v . x ^ hash(v . y)^ hash(v . z)^ hash(v . w));}

float floatConstruct(int m){
    const int ieeeMantissa = 0x007FFFFF;
    const int ieeeOne = 0x3F800000;
    m &= ieeeMantissa;
    m |= ieeeOne;
    float f = intBitsToFloat(m);
    return f - 1.0f;
}

float random(float x){ return floatConstruct(hash(floatBitsToInt(x)));}
float random(vec2 v){ return floatConstruct(hash(floatBitsToInt(v)));}
float random(vec3 v){ return floatConstruct(hash(floatBitsToInt(v)));}
float random(vec4 v){ return floatConstruct(hash(floatBitsToInt(v)));}

float random(){
    float x = float(globalInvocationSMP);
    float y = 10.0f + counter + randomUniform . time;
    float r = random(vec2(x, y));
    counter += 1.0f;
    return r;
}

vec3 randomCosine(in vec3 normal){
    float up = sqrt(random());
    float over = sqrt(- fma(up, up, - 1.0f));
    float around = random()* TWO_PI;

    vec3 directionNotNormal;
    if(abs(normal . x)< SQRT_OF_ONE_THIRD){
        directionNotNormal = vec3(1, 0, 0);
    } else if(abs(normal . y)< SQRT_OF_ONE_THIRD){
        directionNotNormal = vec3(0, 1, 0);
    } else {
        directionNotNormal = vec3(0, 0, 1);
    }
    vec3 perpendicular1 = normalize(cross(normal, directionNotNormal));
    vec3 perpendicular2 = cross(normal, perpendicular1);
    return normalize(
        fma(normal, vec3(up),
            fma(perpendicular1, vec3(cos(around))* over,
                 perpendicular2 * vec3(sin(around))* over
            )
        )
    );
}

vec3 randomDirectionInSphere(){
    float up = random()* 2.0f - 1.0f;
    float over = sqrt(1.0f - up * up);
    float around = random()* TWO_PI;
    return normalize(vec3(up, cos(around)* over, sin(around)* over));
}
#line 14 "./render/testmat.comp"




layout(local_size_x = 64, local_size_y = 1, local_size_z = 1)in;

const uint64_t NOT_EXIST = 0xFFFFFFFFFFFFFFFFul;


const int M_SHADOWED =(1 << 6);
const int M_TRANSPARENT =(1 << 7);
const int M_REFLECTIVE =(1 << 8);
const int M_ENVIRONMENT =(1 << 4);
const int M_ADDITIVE =(1 << 2);

struct Submat {
    vec4 diffuse;
    vec4 specular;
    vec4 transmission;
    vec4 emissive;
    float ior;
    float reflectivity;
    float s1;
    float s2;
    uint64_t diffusePart;
    uint64_t specularPart;
    uint64_t bumpPart;
    uint64_t emissivePart;
    int flags;
    int nkvd0;
    int nkvd1;
    int nkvd2;
};

layout(std430, binding = 0)buffer ssbo0 { Submat submats[];};

vec4 fetchPart(in uint64_t binding, in vec2 texcoord){
    return texture(sampler2D(binding), texcoord);
}

vec4 fetchPart(in uint64_t binding, in vec2 texcoord, in ivec2 offset){
    return textureOffset(sampler2D(binding), texcoord, offset);
}


vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);

    if((mat . flags & M_ENVIRONMENT)> 0){
        vec3 reflected = reflect(direct, normal);


        float m = 1.0 /(2.0 * sqrt(dot(reflected, reflected)));
        texcoord . s = reflected . x * m + 0.5;
        texcoord . t = reflected . y * m + 0.5;
    }

    if(mat . diffusePart == NOT_EXIST){
        result = mat . diffuse;
    } else {
        result = fetchPart(mat . diffusePart, texcoord)* clamp(mat . diffuse *(1.25f), vec4(0.0f), vec4(1.0f));
    }

    if((mat . flags & M_REFLECTIVE)> 0){
        result . w = 1.0f;
    }


    return result;
}

vec4 fetchSpecular(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);

    if(mat . specularPart == NOT_EXIST){
        result = mat . specular;
    } else {
        result = fetchPart(mat . specularPart, texcoord);
    }

    bool reflfilter =((mat . flags & M_REFLECTIVE)> 0 ||(mat . flags & M_ENVIRONMENT)> 0)&&(mat . flags & M_TRANSPARENT)< 1;
    result . xyz = reflfilter ?((mat . flags & M_REFLECTIVE)> 0 ? vec3(0.5): vec3(0.2)): vec3(0.0f);


    return result;
}

vec4 fetchEmissive(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    if(mat . emissivePart == NOT_EXIST){
        return mat . emissive;
    } else {
        return fetchPart(mat . emissivePart, texcoord);
    }
    return vec4(0.0f);
}

vec4 fetchTransmission(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    return mat . transmission;
}


vec4 fetchNormal(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    if(mat . bumpPart == NOT_EXIST){
        return vec4(0.5f, 0.5f, 1.0f, 1.0f);
    } else {
        return fetchPart(mat . bumpPart, texcoord);
    }
    return vec4(0.0f);
}

vec4 fetchNormal(in Submat mat, in vec2 texcoord, in ivec2 offset, in vec3 direct, in vec3 normal){
    if(mat . bumpPart == NOT_EXIST){
        return vec4(0.5f, 0.5f, 1.0f, 1.0f);
    } else {
        return fetchPart(mat . bumpPart, texcoord, offset);
    }
    return vec4(0.0f);
}



const float nearone = 0.9999f;
const float nearzero = 0.0001f;

vec3 getNormalMapping(in Submat mat, vec2 texcoordi, in vec3 direct, in vec3 normal){
    vec3 tc = fetchNormal(mat, texcoordi, direct, normal). xyz;
    if(abs(tc . x - tc . y)< nearzero && abs(tc . x - tc . z)< nearzero){
        const ivec3 off = ivec3(- 1, 0, 1);
        const float size = 1.0f;
        const float pike = 2.0f;
        vec3 p00 = vec3(0.0f, 0.0f, fetchNormal(mat, texcoordi, off . yy, direct, normal). x * pike);
        vec3 p01 = vec3(size, 0.0f, fetchNormal(mat, texcoordi, off . zy, direct, normal). x * pike);
        vec3 p10 = vec3(0.0f, size, fetchNormal(mat, texcoordi, off . yz, direct, normal). x * pike);
        return normalize(cross(p01 - p00, p10 - p00));
    } else {
        return normalize(fma(tc, vec3(2.0f), vec3(- 1.0f)));
    }
    return vec3(0.0, 0.0, 1.0);
}

float computeFresnel(in vec3 normal, in vec3 indc, in float n1, in float n2){

    float cosi = dot(normal, normalize(indc));
    float cost = dot(normal, normalize(refract(indc, normal, n1 / n2)));
    float Rs = fma(n1, cosi, - n2 * cost)/ fma(n1, cosi, n2 * cost);
    float Rp = fma(n1, cost, - n2 * cosi)/ fma(n1, cost, n2 * cosi);
    return clamp(fma(Rs, Rs, Rp * Rp)/ 2.0f, 0.0f, 1.0f);
}

float mlength(vec3 mcolor){
    return max(mcolor . x, max(mcolor . y, mcolor . z));
}

vec3 glossy(in vec3 dir, in vec3 normal, in float refli){
    return mix(normalize(dir), randomCosine(normal), clamp(sqrt(random())* refli, 0.0f, 1.0f));
}

Ray reflection(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal, in float glossiness){
    if(newRay . params . w < 1){
        newRay . direct . xyz = reflect(newRay . direct . xyz, normal);
        newRay . color . xyz *= pow(color, vec3(GAMMA))* nearone;
        newRay . extended . x = 0;

        newRay . params . y = min(1, newRay . params . y);
    }
    return newRay;
}

Ray refraction(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal, in float inior, in float outior, in float glossiness){
    if(newRay . params . w < 1){
        newRay . direct . xyz = normalize(glossy(refract(newRay . direct . xyz, normal, inior / outior), - normal, glossiness));
        newRay . color . xyz *= pow(color, vec3(GAMMA))* nearone;
    }

    if(abs(inior - outior)< 0.0001f || newRay . params . w < 1){
        newRay . params . y += 1;
    } else {
        newRay . extended . x = 0;
    }

    return newRay;
}

Ray diffuse(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal){
    if(newRay . params . w < 1){
        newRay . color . xyz *= pow(color, vec3(GAMMA))* nearone;
        newRay . direct . xyz = randomCosine(normal);
        newRay . params . y = min(2, newRay . params . y);
        newRay . params . z = 1;
        newRay . extended . x = 0;
    }
    return newRay;
}

Ray promised(in Ray newRay, in Hit hit, in vec3 normal){
    newRay . params . y += 1;
    return newRay;
}

Ray emissive(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal){
    if(newRay . params . w < 1){
        vec3 lightCenter = normalize(lightUniform . lightVector . xyz)* lightUniform . lightDistance;
        vec3 ldiff = lightCenter - newRay . origin . xyz;
        float intensivity = max((lightUniform . lightRadius * lightUniform . lightRadius)/ dot(ldiff, ldiff)* clamp(dot(normalize(ldiff), normal), 0.6f, 1.0f), 0.0f);

        newRay . final . xyz = max(newRay . color . xyz * pow(color, vec3(GAMMA))* nearone, vec3(0.0f));
        newRay . final = max(newRay . final, vec4(0.0f));
        newRay . actived = 0;
        newRay . extended . x = 1;
    }
    return newRay;
}

Ray lighted(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal){
    if(newRay . params . w < 1){
        vec3 lightCenter = normalize(lightUniform . lightVector . xyz)* lightUniform . lightDistance;
        vec3 ldiff = lightCenter - newRay . origin . xyz;
        float intensivity = max((lightUniform . lightRadius * lightUniform . lightRadius)/ dot(ldiff, ldiff)* clamp(dot(normalize(ldiff), normal), 0.6f, 1.0f), 0.0f);

        newRay . final . xyz = max(newRay . color . xyz * pow(color, vec3(GAMMA))* nearone * intensivity, vec3(0.0f));
        newRay . final . xyz = newRay . final . xyz /(lightUniform . lightRadius * lightUniform . lightRadius)* lightUniform . lightColor . xyz;

        newRay . final = max(newRay . final, vec4(0.0f));
        newRay . actived = 0;
        newRay . extended . x = 1;
    }
    return newRay;
}

int applyLight(in Ray directRay, inout Ray newRay, in Hit hit, in vec3 normal){
    if(newRay . params . w < 1){
        newRay . params . x = createRay(directRay);
        newRay . extended . x = 1;
        storeHit(newRay . params . x, hit);
        return newRay . params . x;
    }
    return - 1;
}

int emitRay(in Ray originRay, in Ray directRay, in Hit hit, in vec3 normal, in float coef, in bool additive){
    if(originRay . params . w < 1){
        directRay . color . xyz *= coef;
        directRay . final . xyz *= coef;

        int ps = createRay(directRay);
        storeHit(ps, hit);
        return ps;
    }
    return - 1;
}

vec3 sLight(){
    vec3 lightCenter = normalize(lightUniform . lightVector . xyz)* lightUniform . lightDistance;
    return fma(randomDirectionInSphere(), vec3(lightUniform . lightRadius), lightCenter);
}

Ray directLight(in Ray directRay, in Hit hit, in vec3 color, in vec3 normal){
    if(directRay . params . w < 1){

        directRay . params . y = 1;
        directRay . actived = 1;
        directRay . params . w = 1;
        directRay . direct . xyz = normalize(sLight()- directRay . origin . xyz);
        directRay . extended . x = 0;

        vec3 lightCenter = normalize(lightUniform . lightVector . xyz)* lightUniform . lightDistance;
        vec3 ldiff = lightCenter - directRay . origin . xyz;







        directRay . color . xyz *= pow(color, vec3(GAMMA))* clamp(dot(directRay . direct . xyz, normal), 0.0f, 1.0f);
    }

    return directRay;
}

void main(){
    int offT = int(gl_GlobalInvocationID . x);
    int it = offT;
    if(it >= samplerUniform . rayCount)return;
    int t = actived[it];

    Ray newRay = fetchRayDirect(t);
    if(newRay . actived < 1)return;

    Hit hit = fetchHitDirect(t);
    if(hit . shaded > 0 || hit . dist >= INFINITY)return;

    uint l = gl_LocalInvocationID . x;
    if(hit . materialID < 0)return;

    Submat material = submats[hit . materialID];

    hit . shaded = 1;
    globalInvocationSMP = int(t);

    vec3 dir = normalize(newRay . direct . xyz);
    vec3 prenormal = normalize(hit . normal . xyz);

    float inior = 1.0f;
    float outior = material . ior;
    const float inside = dot(prenormal, dir);
    if(inside >= 0.0f){
        float tmp = inior;
        inior = outior;
        outior = tmp;
    }

    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
    vec3 tan = normalize(hit . tangent . xyz);
    mat3 tbn = mat3(tan, cross(normal, tan), normal);
    normal = normalize(tbn * getNormalMapping(material, hit . texcoord, newRay . direct . xyz, normal));
    normal = faceforward(normal, dir, normal);

    const float glossiness = clamp(1.0f / log2(material . reflectivity), 0.0f, 1.0f);
    vec4 tx = fetchDiffuse(material, hit . texcoord, newRay . direct . xyz, normal)* vec4(hit . color . xyz, 1.0f);
    vec4 tts = 1.0f - clamp(fetchTransmission(material, hit . texcoord, newRay . direct . xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 emi = fetchEmissive(material, hit . texcoord, newRay . direct . xyz, normal);
    emi . xyz = emi . xyz / max(mlength(emi . xyz), 0.0001f)* 10.0f;
    vec4 sp = fetchSpecular(material, hit . texcoord, newRay . direct . xyz, normal);
    vec4 rc = vec4(sp . xyz, 1.0f);


    const float emis = clamp(mlength(emi . xyz), 0.0f, 1.0f)*(newRay . params . w < 1 ? 1.0f : 0.0f);
    const float spic = mlength(rc . xyz);
    const float prom = tx . a;
    const float fres = computeFresnel(hit . normal . xyz, newRay . direct . xyz, inior, outior)*(inside <= 0.0f ? 1.0f : 0.0f);

    vec3 lightCenter = normalize(lightUniform . lightVector . xyz)* lightUniform . lightDistance;
    float intensivity = max(clamp(dot(normalize(lightCenter - newRay . origin . xyz), normal), 0.0f, 1.0f), 0.0f);



    float trns = prom;
    float atrns = 1.0f - prom;
    float aspic = 1.0f - spic;

    bool isAdditive =(material . flags & M_ADDITIVE)> 0;
    bool shadowed =(material . flags & M_SHADOWED)> 0 && !((material . flags & M_ENVIRONMENT)> 0 &&(material . flags & M_TRANSPARENT)> 0);

    const float shadowIntense = 0.4f;
    const float unShadowIntense = 1.0f - shadowIntense;


    if(trns > 0.999f &&(material . flags & M_TRANSPARENT)< 1 && ! isAdditive){
        if(aspic > 0.0){
            if(shadowed){
                if(unShadowIntense > 0.0f)emitRay(newRay, directLight(newRay, hit, tx . xyz, normal), hit, normal, aspic * unShadowIntense, false);
                if(shadowIntense > 0.0f)emitRay(newRay, emissive(newRay, hit, tx . xyz, normal), hit, normal, aspic * shadowIntense, false);
            } else {
                emitRay(newRay, emissive(newRay, hit, tx . xyz *(isAdditive ? 1.0f : trns), normal), hit, normal, aspic, false);
            }
        }

        newRay = reflection(newRay, hit, vec3(1.0f), normal, 0.0f);
        newRay . color . xyz *= spic;

        if(shadowed && spic < 0.0001f){
            newRay . actived = 0;
        }
    } else


    if(newRay . params . w < 1){
        if(trns > 0.0f){
            if(shadowed){
                if(unShadowIntense > 0.0f)emitRay(newRay, directLight(newRay, hit, tx . xyz, normal), hit, normal,(trns)* unShadowIntense, false);
                if(shadowIntense > 0.0f)emitRay(newRay, emissive(newRay, hit, tx . xyz, normal), hit, normal,(trns)* shadowIntense, false);
            } else {
                emitRay(newRay, emissive(newRay, hit, tx . xyz, normal), hit, normal, trns, isAdditive);
            }
        }

        if(spic > 0.0f && random()< spic){
            newRay = reflection(newRay, hit, vec3(1.0f), normal, 0.0f);
        } else {
            newRay = promised(newRay, hit, normal);
            newRay . color . xyz *= isAdditive ? 1.0f : atrns;
            if(shadowed && ! isAdditive && atrns < 0.0001f){
                newRay . actived = 0;
            }
        }

    }


    else {
        if(atrns > 0.0f && random()< atrns || isAdditive){
            newRay = promised(newRay, hit, normal);
        } else {
            newRay = emissive(newRay, hit, tx . xyz, normal);
        }
    }



    storeHit(t, hit);
    storeRay(t, newRay);

}
