#version 450
#extension GL_GOOGLE_include_directive : enable
#line 1 "./hlbvh/aabbmaker.comp"


#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#line 1 "./hlbvh/../include/structs.glsl"
struct Minmax {
    vec4 mn;
    vec4 mx;
};

struct Thash {
    int triangle;
    int previous;
};

struct Voxel {
    int depthLeaf;
    int parent;
    int last;
    int suboff;
    int coord;
    int count;
    int _t0;
};

struct Ray {
    int idx;
    int prev;
    int texel;
    int actived;
    vec4 origin;
    vec4 direct;
    vec4 color;
    vec4 final;
    ivec4 params;
    ivec4 extended;
};

struct Hit {
    vec4 normal;
    vec4 tangent;
    vec4 color;
    vec2 texcoord;
    float dist;
    float _t0;
    int triangle;
    int materialID;
    int shaded;
    int _t2;
};

struct Texel {
    int last;
    int count;
    float x;
    float y;
};

struct Stride2f {
    float x;
    float y;
};

struct Stride3f {
    float x;
    float y;
    float z;
};

struct Stride3i {
    int x;
    int y;
    int z;
};

struct Stride4f {
    float x;
    float y;
    float z;
    float w;
};

vec2 toVec2(in Stride2f a){
    return vec2(a . x, a . y);
}

vec3 toVec3(in Stride3f a){
    return vec3(a . x, a . y, a . z);
}

vec4 toVec4(in Stride4f a){
    return vec4(a . x, a . y, a . z, a . w);
}

ivec3 toVec3(in Stride3i a){
    return ivec3(a . x, a . y, a . z);
}

Stride2f toStride2(in vec2 a){
    Stride2f o;
    o . x = a . x;
    o . y = a . y;
    return o;
}

Stride3f toStride3(in vec3 a){
    Stride3f o;
    o . x = a . x;
    o . y = a . y;
    o . z = a . z;
    return o;
}

Stride4f toStride4(in vec4 a){
    Stride4f o;
    o . x = a . x;
    o . y = a . y;
    o . z = a . z;
    o . w = a . w;
    return o;
}

struct bbox {
    vec4 pmin;
    vec4 pmax;
};

struct Leaf {
    bbox box;
    int parent;
    int _t0;
    int _t1;
    int _t2;
};

struct HlbvhNode {
    bbox box;
    ivec2 range;
    int parent;
    int left;
    int right;
    int _t0;
    int _t1;
    int _t2;
};
#line 7 "./hlbvh/aabbmaker.comp"
#line 1 "./hlbvh/../include/uniforms.glsl"
struct RandomUniformStruct {
    float time;
};

struct MinmaxUniformStruct {
    int heap;
    float prec;
};

struct MaterialUniformStruct {
    int materialID;
    int doubleSide;
    float reflectivity;
    float dissolve;
    float illumPower;
    float ior;
};

struct SamplerUniformStruct {
    vec2 sceneRes;
    int samplecount;
    int rayCount;
    int iteration;
    int phase;
    int maxSamples;
    int currentSample;
    int maxFilters;
};

struct LightUniformStruct {
    vec4 lightVector;
    vec4 lightColor;
    float lightRadius;
    float lightDistance;
};

struct GeometryUniformStruct {
    mat4 transform;
    mat4 transformInv;
    vec4 colormod;
    float offset;

    int materialID;
    int triangleCount;
    int triangleOffset;
    int unindexed;
    int loadOffset;
    int NB_mode;
    int unk1;
};

struct HelperUniformStruct {
    ivec4 range;
};

struct OctreeUniformStruct {
    mat4 project;
    mat4 unproject;
    int maxDepth;
    int currentDepth;
    int nodeCount;
};

struct CameraUniformStruct {
    mat4 projInv;
    mat4 camInv;
    mat4 camInv2;
    vec4 eye;
    vec4 view;
    float prob;
    int enable360;
};

layout(std140, binding = 0)uniform ubo0 { RandomUniformStruct randomUniform;};
layout(std140, binding = 1)uniform ubo1 { MinmaxUniformStruct minmaxUniform;};
layout(std140, binding = 2)uniform ubo2 { MaterialUniformStruct materialUniform;};
layout(std140, binding = 3)uniform ubo3 { SamplerUniformStruct samplerUniform;};
layout(std140, binding = 4)uniform ubo4 { LightUniformStruct lightUniform;};
layout(std140, binding = 5)uniform ubo5 { GeometryUniformStruct geometryUniform;};
layout(std140, binding = 6)uniform ubo6 { HelperUniformStruct helperUniform;};
layout(std140, binding = 7)uniform ubo7 { OctreeUniformStruct octreeUniform;};
layout(std140, binding = 8)uniform ubo8 { CameraUniformStruct cameraUniform;};
#line 8 "./hlbvh/aabbmaker.comp"
#line 1 "./hlbvh/../include/constants.glsl"
const int LONGEST = 0xFFFFFFFF;
const float INFINITY = 10000.0f;
const float GAMMA = 1.0f;
const float PI = 3.1415926535897932384626422832795028841971f;
const float TWO_PI = 6.2831853071795864769252867665590057683943f;
const float SQRT_OF_ONE_THIRD = 0.5773502691896257645091487805019574556476f;
const float E = 2.7182818284590452353602874713526624977572f;


#line 9 "./hlbvh/aabbmaker.comp"
#line 1 "./hlbvh/../include/fast_math.glsl"
int pow2(in int d){
    return d <= 0 ? 1 :(2 <<(d - 1));
}

float pow2(in float d){
    return exp2(d);
}
#line 10 "./hlbvh/aabbmaker.comp"
#line 1 "./hlbvh/../include/vertex.glsl"
 layout(std430, binding = 3)buffer ssbo3 { Stride3f verts[];};
layout(std430, binding = 4)buffer ssbo4 { int indics[];};
layout(std430, binding = 5)buffer ssbo5 { Stride3f norms[];};
layout(std430, binding = 6)buffer ssbo6 { Stride2f texcs[];};
layout(std430, binding = 7)buffer ssbo7 { int mats[];};
layout(std430, binding = 16)buffer ssbo16 { Stride4f vcolors[];};
#line 11 "./hlbvh/aabbmaker.comp"
#line 1 "./hlbvh/../include/morton.glsl"
int part1By2_64(in int a){
    int x = a & 0x000003ff;
    x =(x |(x << 16))& 0xff0000ff;
    x =(x |(x << 8))& 0x0300f00f;
    x =(x |(x << 4))& 0x030c30c3;
    x =(x |(x << 2))& 0x09249249;
    return x;
}

int encodeMorton3_64(in ivec3 a)
{
    return part1By2_64(a . x)|(part1By2_64(a . y)<< 1)|(part1By2_64(a . z)<< 2);
}

int compact1By2_64(in int a)
{
    int x = a & 0x09249249;
    x =(x |(x >> 2))& 0x030c30c3;
    x =(x |(x >> 4))& 0x0300f00f;
    x =(x |(x >> 8))& 0xff0000ff;
    x =(x |(x >> 16))& 0x000003ff;
    return x;
}

ivec3 decodeMorton3_64(in int code)
{
    return ivec3(compact1By2_64(code >> 0), compact1By2_64(code >> 1), compact1By2_64(code >> 2));
}

ivec2 decodeDepthLeaf(int dl){
    return ivec2((dl >> 31)& 1, dl & 0x7FFFFFFF);
}

int encodeDepthLeaf(ivec2 dl){
    return((dl . x & 1)<< 31)|(dl . y & 0x7FFFFFFF);
}
#line 12 "./hlbvh/aabbmaker.comp"

layout(std430, binding = 0)buffer OutLeafBlock {
    Leaf OutLeafs[];
};

layout(std430, binding = 1)buffer MortoncodesBlock {
    ivec2 Mortoncodes[];
};

int CalculateMortonCode(in vec3 p){
    float x = round(min(max(p . x * 1024.0f, 0.0f), 1023.0f));
    float y = round(min(max(p . y * 1024.0f, 0.0f), 1023.0f));
    float z = round(min(max(p . z * 1024.0f, 0.0f), 1023.0f));
    return encodeMorton3_64(ivec3(x, y, z));
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1)in;

void main(){
    int t = int(gl_GlobalInvocationID . x);
 Mortoncodes[t]= ivec2(0xFFFFFFFF);

    if(t < geometryUniform . triangleCount){
        vec4 mn = vec4(INFINITY);
        vec4 mx = vec4(- INFINITY);
        vec3 triverts[3];

        int tri3 = t * 3;
        for(int x = 0;x < 3;x ++){
            int j = indics[tri3 + x];
            triverts[x]=(octreeUniform . project * vec4(toVec3(verts[j]), 1.0f)). xyz;
        }

        mn . xyz = min(triverts[0], min(triverts[1], triverts[2]))- 0.0001f;
        mx . xyz = max(triverts[0], max(triverts[1], triverts[2]))+ 0.0001f;

        vec3 center =(triverts[0]+ triverts[1]+ triverts[2])* 0.3333333333f;
        Mortoncodes[t]. x = t;
        Mortoncodes[t]. y = CalculateMortonCode(center);

        OutLeafs[t]. box . pmin = mn;
        OutLeafs[t]. box . pmax = mx;
        OutLeafs[t]. parent = - 1;
    }
}
