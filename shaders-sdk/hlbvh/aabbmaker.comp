#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/constants.glsl"
#include "../include/fast_math.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"

layout( std430, binding = 0 ) buffer OutLeafBlock {
    Leaf OutLeafs[];
};

layout( std430, binding = 1 ) buffer MortoncodesBlock {
    ivec2 Mortoncodes[];
};

int CalculateMortonCode( in vec3 p) {
    float x = round(min(max(p.x * 1024.0f, 0.0f), 1023.0f));
    float y = round(min(max(p.y * 1024.0f, 0.0f), 1023.0f));
    float z = round(min(max(p.z * 1024.0f, 0.0f), 1023.0f));
    return encodeMorton3_64(ivec3(x, y, z));
}

layout (local_size_x = RENDERER_CU, local_size_y = 1, local_size_z = 1) in;

void main() {
    int t = int(gl_GlobalInvocationID.x);
	Mortoncodes[t] = ivec2(0xFFFFFFFF);
	
    if (t < geometryUniform.triangleCount) {
        vec4 mn = vec4(INFINITY);
        vec4 mx = vec4(-INFINITY);
        vec3 triverts[3];

        int tri3 = t * 3;
        for (int x=0;x<3;x++) {
            int j = indics[tri3 + x];
            triverts[x] = (octreeUniform.project * vec4(toVec3(verts[j]), 1.0f)).xyz;
        }

        mn.xyz = min(triverts[0], min(triverts[1], triverts[2])) - 0.0001f;
        mx.xyz = max(triverts[0], max(triverts[1], triverts[2])) + 0.0001f;
        
        vec3 center = (triverts[0] + triverts[1] + triverts[2]) * 0.3333333333f;
        //vec3 center = (mn.xyz + mx.xyz) * 0.5f;
        Mortoncodes[t].x = t;
        Mortoncodes[t].y = CalculateMortonCode(center);
        
        OutLeafs[t].box.pmin = mn;
        OutLeafs[t].box.pmax = mx;
        OutLeafs[t].parent = -1;
    }
}