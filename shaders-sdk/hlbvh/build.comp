#version 450

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "./includes.glsl"

layout(binding=0) uniform atomic_uint NodeCounter;

int clzm(in int x){
    return (31 - findMSB(x));
}

int delta(in int i1, in int i2){
    int left  = min(i1, i2);
    int right = max(i1, i2);
    if (left < 0 || right >= geometryUniform.triangleCount) {
        return -1;
    }
    int leftcode = Mortoncodes[left].y;
    int rightcode = Mortoncodes[right].y;
    return leftcode != rightcode ? clzm(leftcode ^ rightcode) : (32 + clzm(left ^ right));
}

int findSplit(in int left, in int right){
    int numidentical = delta(left, right);
    for(int i=0;i<10000;i++){
        int newsplit = (right + left) / 2;
        if (delta(left, newsplit) > numidentical) {
            left = newsplit;
        } else {
            right = newsplit;
        }
        if(right <= left + 1) break;
    }
    return left;
}

void main() {
    //Start from next childs
    int globalID = int(gl_GlobalInvocationID.x) + Range.x;
    if (globalID < Range.y) {

        //If begun
        if (octreeUniform.currentDepth == 1) {
            Nodes[0].parent = -1;
            Nodes[0].range = ivec2(0, geometryUniform.triangleCount);
            Nodes[0].left = Nodes[0].range.x;
            Nodes[0].right = Nodes[0].range.y;
        }

        HlbvhNode node = Nodes[globalID];
        if (node.range.x != node.range.y) {
            int split = findSplit(node.range.x, node.range.y);
            int childOffset = 1 + int(atomicCounterIncrement(NodeCounter)) * 2;
            int c1idx = childOffset;
            int c2idx = childOffset + 1;

            //Link
            Nodes[globalID].left  = c1idx;
            Nodes[globalID].right = c2idx;
            
            //Left
            Nodes[c1idx].parent = globalID;
            Nodes[c1idx].left = Nodes[c1idx].right = node.range.x;
            Nodes[c1idx].range = ivec2(node.range.x, split);

            //Right
            Nodes[c2idx].parent = globalID;
            Nodes[c2idx].left = Nodes[c2idx].right = node.range.y;
            Nodes[c2idx].range = ivec2(split + 1, node.range.y);
        } else {

            //Link with leafs and triangles
            Leafs[node.range.x].parent = globalID;
            Nodes[globalID].box = Leafs[node.range.x].box;
        }
    }
}