#version 450

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require
#extension GL_ARB_bindless_texture : require

#include "../include/structs.glsl"
#include "../include/constants.glsl"
#include "../include/uniforms.glsl"
#include "../include/fast_math.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"

#define DIRECT_LIGHT
#define REFLECTION_TEST

layout (local_size_x = RENDERER_CU, local_size_y = 1, local_size_z = 1) in;

const uint64_t NOT_EXIST = 0xFFFFFFFFFFFFFFFFul;


const int M_SHADOWED = (1 <<  6);
const int M_TRANSPARENT = (1 <<  7);
const int M_REFLECTIVE = (1 <<  8);
const int M_ENVIRONMENT = (1 <<  4);
const int M_ADDITIVE = (1 <<  2);

struct Submat {
    vec4 diffuse;
    vec4 specular;
    vec4 transmission;
    vec4 emissive;
    float ior;
    float reflectivity;
    float s1;
    float s2;
    uint64_t diffusePart;
    uint64_t specularPart;
    uint64_t bumpPart;
    uint64_t emissivePart;
    int flags;
    int nkvd0;
    int nkvd1;
    int nkvd2;
};

layout ( std430, binding=0) buffer ssbo0 {Submat submats[];};

vec4 fetchPart(in uint64_t binding, in vec2 texcoord){
    return texture(sampler2D(binding), texcoord);
}

vec4 fetchPart(in uint64_t binding, in vec2 texcoord, in ivec2 offset){
    return textureOffset(sampler2D(binding), texcoord, offset);
}


vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);

    if((mat.flags & M_ENVIRONMENT) > 0){
        vec3 reflected = reflect(direct, normal);
        reflected.z += 1.0f;

        float m = 1.0 / (2.0 * sqrt(dot(reflected, reflected)));
        texcoord.s = reflected.x * m + 0.5;
        texcoord.t = reflected.y * m + 0.5;
    }
    
    if(mat.diffusePart == NOT_EXIST){
        result = mat.diffuse;
    } else {
        result = fetchPart(mat.diffusePart, texcoord) * ((mat.flags & M_TRANSPARENT) < 1 && (mat.flags & M_ENVIRONMENT) < 1 ? vec4(1.0f) : mat.diffuse);
    }
    //result.w = ((mat.flags & M_REFLECTIVE) > 0 && (mat.flags & M_TRANSPARENT) < 1) ? 1.0f : result.w;
    return result;
}

vec4 fetchSpecular(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);
    
    if(mat.specularPart == NOT_EXIST){
        result = mat.specular;
    } else {
        result = fetchPart(mat.specularPart, texcoord);
    }
    
    bool reflfilter = ((mat.flags & M_REFLECTIVE) > 0 || (mat.flags & M_ENVIRONMENT) > 0) && (mat.flags & M_TRANSPARENT) < 1;
    result.xyz = reflfilter ? ((mat.flags & M_REFLECTIVE) > 0 ? vec3(0.5) : vec3(0.2)) : vec3(0.0f);
    
    result = clamp(result, vec4(0.0f), vec4(1.0f));
    return result;
}

vec4 fetchEmissive(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    if(mat.emissivePart == NOT_EXIST){
        return mat.emissive;
    } else {
        return fetchPart(mat.emissivePart, texcoord);
    }
    return vec4(0.0f);
}

vec4 fetchTransmission(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    return mat.transmission;
}


vec4 fetchNormal(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    if(mat.bumpPart == NOT_EXIST){
        return vec4(0.5f, 0.5f, 1.0f, 1.0f);
    } else {
        return fetchPart(mat.bumpPart, texcoord);
    }
    return vec4(0.0f);
}

vec4 fetchNormal(in Submat mat, in vec2 texcoord, in ivec2 offset, in vec3 direct, in vec3 normal){
    if(mat.bumpPart == NOT_EXIST){
        return vec4(0.5f, 0.5f, 1.0f, 1.0f);
    } else {
        return fetchPart(mat.bumpPart, texcoord, offset);
    }
    return vec4(0.0f);
}



const float nearone  = 0.9999f;
const float nearzero = 0.0001f;

vec3 getNormalMapping(in Submat mat, vec2 texcoordi, in vec3 direct, in vec3 normal) {
    vec3 tc = fetchNormal(mat, texcoordi, direct, normal).xyz;
    if(abs(tc.x - tc.y) < nearzero && abs(tc.x - tc.z) < nearzero){
        const ivec3 off = ivec3(-1,0,1);
        const float size = 1.0f;
        const float pike = 2.0f;
        vec3 p00 = vec3(0.0f, 0.0f, fetchNormal(mat, texcoordi, off.yy, direct, normal).x * pike);
        vec3 p01 = vec3(size, 0.0f, fetchNormal(mat, texcoordi, off.zy, direct, normal).x * pike);
        vec3 p10 = vec3(0.0f, size, fetchNormal(mat, texcoordi, off.yz, direct, normal).x * pike);
        return normalize(cross(p01 - p00, p10 - p00));
    } else {
        return normalize(fma(tc, vec3(2.0f), vec3(-1.0f)));
    }
    return vec3(0.0, 0.0, 1.0);
}

float computeFresnel(in vec3 normal, in vec3 indc, in float n1, in float n2){
    //float cosi = dot(normal,  normalize(reflect(indc, normal)));
    float cosi = dot(normal,  normalize(indc));
    float cost = dot(normal,  normalize(refract(indc, normal, n1 / n2)));
    float Rs = fma(n1, cosi, - n2 * cost) / fma(n1, cosi, n2 * cost);
    float Rp = fma(n1, cost, - n2 * cosi) / fma(n1, cost, n2 * cosi);
    return clamp(fma(Rs,Rs, Rp*Rp) / 2.0f, 0.0f, 1.0f);
}

float mlength(vec3 mcolor){
    return max(mcolor.x, max(mcolor.y, mcolor.z));
}

vec3 glossy(in vec3 dir, in vec3 normal, in float refli) {
    return mix(normalize(dir), randomCosine(normal), clamp(sqrt(random()) * refli, 0.0f, 1.0f));
}

Ray reflection(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal, in float glossiness){
    newRay.direct.xyz = reflect(newRay.direct.xyz, normal);
    newRay.color.xyz *= pow(color, vec3(GAMMA)) * nearone;
    if (newRay.params.w < 1) {
        newRay.extended.x = 0;
    }
    
    newRay.params.y = min(1, newRay.params.y); //for Debugging only
    return newRay;
}

Ray refraction(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal, in float inior, in float outior, in float glossiness){
    newRay.direct.xyz = normalize(  glossy(refract(newRay.direct.xyz, normal, inior / outior), -normal, glossiness)   );
    newRay.color.xyz *= pow(color, vec3(GAMMA)) * nearone;
    
    if (abs(inior - outior) < 0.0001f || newRay.params.w < 1) {
        newRay.params.y += 1;
    } else {
        newRay.extended.x = 0;
    }
    return newRay;
}

Ray diffuse(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal){
    newRay.color.xyz *= pow(color, vec3(GAMMA)) * nearone;
    newRay.direct.xyz = randomCosine(normal);
    newRay.params.y = min(2, newRay.params.y);
    newRay.params.z = 1;
    if (newRay.params.w < 1) {
        newRay.extended.x = 0;
    }
    return newRay;
}

Ray promised(in Ray newRay, in Hit hit, in vec3 normal){
    newRay.params.y += 1;
    return newRay;
}

Ray emissive(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal){
    if (newRay.params.w < 1) {
        vec3 lightCenter = normalize(lightUniform.lightVector.xyz) * lightUniform.lightDistance;
        vec3 ldiff = lightCenter - newRay.origin.xyz;
        float intensivity = max(clamp(dot(normalize(ldiff), normal), 0.0f, 1.0f), 0.0f);
    
        newRay.final.xyz = max(newRay.color.xyz * pow(color, vec3(GAMMA)) * nearone, vec3(0.0f));
        newRay.final = max(newRay.final, vec4(0.0f));
        newRay.color.xyz = vec3(0.0f);
        newRay.actived = 0;
        newRay.params.y += 1;
        newRay.extended.x = 1;
    }
    return newRay;
}

Ray lighted(in Ray newRay, in Hit hit, in vec3 color, in vec3 normal){
    if (newRay.params.w < 1) {
        vec3 lightCenter = normalize(lightUniform.lightVector.xyz) * lightUniform.lightDistance;
        vec3 ldiff = lightCenter - newRay.origin.xyz;
        float intensivity = clamp(dot(normalize(ldiff), normal), 0.4f, 1.0f);
    
        newRay.final.xyz = max(newRay.color.xyz * pow(color, vec3(GAMMA)) * nearone * intensivity, vec3(0.0f));
        newRay.final = max(newRay.final, vec4(0.0f));
        newRay.color.xyz = vec3(0.0f);
        newRay.actived = 0;
        newRay.params.y += 1;
        newRay.extended.x = 1;
    }
    return newRay;
}



int applyLight(in Ray directRay, inout Ray newRay, in Hit hit, in vec3 normal){
    newRay.params.x = createRay(directRay);
    newRay.extended.x = 1;
    storeHit(newRay.params.x, hit);
    return newRay.params.x;
}

int emitRay(in Ray directRay, in Hit hit, in vec3 normal, in float coef, in bool additive){
    if(additive){
        directRay.final.w *= 0.0f;
    } else {
        directRay.final.w *= coef;
        directRay.color.xyz *= coef;
        directRay.final.xyz *= coef;
    }

    int ps = createRay(directRay);
    storeHit(ps, hit);
    return ps;
}

vec3 sLight(){
    vec3 lightCenter = normalize(lightUniform.lightVector.xyz) * lightUniform.lightDistance;
    return fma(randomDirectionInSphere(), vec3(lightUniform.lightRadius), lightCenter);
}

Ray directLight(in Ray directRay, in Hit hit, in vec3 color, in vec3 normal){
    directRay.params.y = min(1, directRay.params.y);
    directRay.actived = 1;
    directRay.params.w = 1;
    directRay.direct.xyz = normalize(sLight() - directRay.origin.xyz);
    directRay.extended.x = 0;
    
    vec3 lightCenter = normalize(lightUniform.lightVector.xyz) * lightUniform.lightDistance;
    vec3 ldiff = lightCenter - directRay.origin.xyz;
    
    float intensivity = max((lightUniform.lightRadius * lightUniform.lightRadius) / dot(ldiff, ldiff) * clamp(dot(directRay.direct.xyz, normal), 0.0f, 1.0f), 0.0f);
    directRay.color.xyz *= color * intensivity;
    directRay.final.w *= intensivity;
    return directRay;
}

void main() {
    int offT = int(gl_GlobalInvocationID.x);
    int it = offT;
    if (it >= samplerUniform.rayCount) return;
    int t = actived[it];
    
    Ray newRay = fetchRayDirect(t);
    if (newRay.actived < 1) return;
    
    Hit hit = fetchHitDirect(t);
    if (hit.shaded > 0 || hit.dist >= INFINITY) return;
    
    uint l = gl_LocalInvocationID.x;
    Submat material = submats[hit.materialID];
    
    hit.shaded = 1;
    globalInvocationSMP = int(t);
    
    vec3 dir = normalize(newRay.direct.xyz);
    vec3 prenormal = normalize(hit.normal.xyz);

    float inior = 1.0f;
    float outior = material.ior;
    const float inside = dot(prenormal, dir);
    if (inside >= 0.0f) {
        float tmp = inior;
        inior = outior;
        outior = tmp;
    }
    
    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
    vec3 tan = normalize(hit.tangent.xyz);
    mat3 tbn = mat3(tan, cross(normal, tan), normal);
    normal = normalize(tbn * getNormalMapping(material, hit.texcoord, newRay.direct.xyz, normal));
    normal = faceforward(normal, dir, normal);
    
    const float glossiness = clamp(1.0f / log2(material.reflectivity), 0.0f, 1.0f);
    vec4 tx = fetchDiffuse(material, hit.texcoord, newRay.direct.xyz, normal) * vec4(hit.color.xyz, 1.0f);
    vec4 tts = 1.0f - clamp(fetchTransmission(material, hit.texcoord, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 emi = fetchEmissive(material, hit.texcoord, newRay.direct.xyz, normal);
    emi.xyz = emi.xyz / max(mlength(emi.xyz), 0.0001f) * 10.0f;
    vec4 sp = fetchSpecular(material, hit.texcoord, newRay.direct.xyz, normal);
    vec4 rc = vec4(sp.xyz, 1.0f);//vec4(mix(sp.xyz, tx.xyz, glossiness), 1.0f);
    
    //const float trns = clamp(mlength(tts.xyz), 0.0f, 1.0f);
    const float emis = clamp(mlength(emi.xyz), 0.0f, 1.0f) * (newRay.params.w < 1 ? 1.0f : 0.0f);
    const float spic = mlength(rc.xyz);
    const float prom = tx.a; 
    const float fres = computeFresnel(hit.normal.xyz, newRay.direct.xyz, inior, outior) * (inside <= 0.0f ? 1.0f : 0.0f);
    
    vec3 lightCenter = normalize(lightUniform.lightVector.xyz) * lightUniform.lightDistance;
    float intensivity = max(clamp(dot(normalize(lightCenter - newRay.origin.xyz), normal), 0.0f, 1.0f), 0.0f);

#ifdef REFLECTION_TEST
    
    float rlspc = 1.0f - spic;
    float trns = prom; //* rlspc;
    float atrns = 1.0f - prom;

    bool isAdditive = (material.flags & M_ADDITIVE) > 0;
    bool shadowed = (material.flags & M_SHADOWED) > 0;
    
    if (trns > 0.999f && !isAdditive) {
        if(shadowed){
            emitRay(lighted(newRay, hit, tx.xyz, normal), hit, normal, 1.0f - spic, false);
        } else {
            emitRay(emissive(newRay, hit, tx.xyz, normal), hit, normal, 1.0f - spic, false);
        }
        
        newRay = reflection(newRay, hit, vec3(1.0f), normal, 0.0f);
        newRay.final *= spic;
        newRay.color.xyz *= spic;
    } else {
        if (spic > 0.0f && random() < spic) {
            newRay = reflection(newRay, hit, vec3(1.0f), normal, 0.0f);
        } else {
            if(shadowed){
                emitRay(lighted(newRay, hit, tx.xyz, normal), hit, normal, trns, isAdditive);
            } else {
                emitRay(emissive(newRay, hit, tx.xyz, normal), hit, normal, trns, isAdditive);
            }

            newRay = promised(newRay, hit, normal);

            if (isAdditive){
                //newRay.final.w *= 1.0f;
                //newRay.color.xyz *= 1.0f;
            } else {
                newRay.final.w *= atrns;
                newRay.color.xyz *= atrns;
            }
        }
    }
    
    if (newRay.final.w < 0.0001f && !isAdditive) {
        newRay.actived = 0;
    }
    
    //newRay.final.xyz = hit.normal.xyz * 0.5f + 0.5f;
    //newRay.actived = 0;

    //newRay.final.w *= prom;
    //newRay.color.xyz *= prom;
    //newRay.final.xyz *= prom;
    
#endif

    storeHit(t, hit);
    storeRay(t, newRay);

}
