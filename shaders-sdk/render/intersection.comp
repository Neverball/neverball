#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/structs.glsl"
#include "../include/constants.glsl"
#include "../include/uniforms.glsl"
#include "../include/fast_math.glsl"
#include "../include/rays.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"

vec2 intersectCube(in vec3 origin, in vec3 ray, in vec3 cubeMin, in vec3 cubeMax) {
    vec3 dr = vec3(1.0f) / ray;
    vec3 tMin = (cubeMin - origin) * dr;
    vec3 tMax = (cubeMax - origin) * dr;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    vec2 dsts = vec2(INFINITY);
    if ( tFar > tNear && tFar >= 0.0f && tNear < INFINITY ) {
        dsts = vec2(tNear, tFar);
    }
    return dsts;
}

vec3 normalForCube(vec3 hit, vec3 cubeMin, vec3 cubeMax){
    vec4 norm = vec4(0.0f);
    if(hit.x < cubeMin.x + 0.0001f) {norm += vec4(-1.0f,  0.0f,  0.0f, 1.0f);}
    if(hit.x > cubeMax.x - 0.0001f) {norm += vec4( 1.0f,  0.0f,  0.0f, 1.0f);}  
    if(hit.y < cubeMin.y + 0.0001f) {norm += vec4( 0.0f, -1.0f,  0.0f, 1.0f);} 
    if(hit.y > cubeMax.y - 0.0001f) {norm += vec4( 0.0f,  1.0f,  0.0f, 1.0f);} 
    if(hit.z < cubeMin.z + 0.0001f) {norm += vec4( 0.0f,  0.0f, -1.0f, 1.0f);} 
    if(hit.z > cubeMax.z - 0.0001f) {norm += vec4( 0.0f,  0.0f,  1.0f, 1.0f);}
    return normalize(norm.xyz / norm.w);
}

float intersectTriangle(in vec3 orig, in vec3 dir, inout vec3 ve[3], inout vec2 UV, inout vec3 norm) {
    vec3 e1 = vec3(ve[1] - ve[0]);
    vec3 e2 = vec3(ve[2] - ve[0]);
    vec3 dirc  = vec3(dir);
    vec3 origc = vec3(orig);
    
    vec3 p = -cross(dirc, e2);
    float det = dot(e1, p);
    if (abs(det) < 0.000001f) return INFINITY;

    vec3 n = normalize(cross(e1, e2));
    float ls = dot(dirc, n);
    if (abs(ls) < 0.000001f) return INFINITY;
    //if (abs(ls) < 0.000001f || ls > 0.0f) return INFINITY;
    
    vec3 T = origc - vec3(ve[0]);
    float pt = dot(T, n) / ls;
    if (pt > 0.0f) return INFINITY;
    
    float idet = 1.0f / det;
    float u = dot(T, p) * idet;
    if (u < 0.0f || u > 1.0f) return INFINITY;

    vec3 q = -cross(T, e1);
    float v = dot(dirc, q) * idet;
    if (v < 0.0f || (u + v) > 1.0f) return INFINITY;

    float t = dot(e2, q) * idet;
    if (t >= 0.0f) {
        UV.x = u;
        UV.y = v;
        norm = n;
        return t;
    }

    return INFINITY;
}

struct TResult {
    float dist;
    int triangle;
    int materialID;
    vec3 normal;
    vec3 tangent;
    vec2 texcoord;
    vec4 color;
    vec2 uv;
};

TResult loadInfo(inout TResult res) {
    const vec2 barys[3] = {vec2(0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f)};

    int tri = res.triangle;
    if (res.dist >= 0.0f && res.dist < INFINITY && tri != LONGEST) {
        vec3 trinorms[3];
        vec3 triverts[3];
        vec2 texcoords[3];
        vec4 colors[3];
        
        for (int x=0;x<3;x++) {
            int j = indics[tri * 3 + x];
            triverts[x] = toVec3(verts[j]);
            trinorms[x] = toVec3(norms[j]);
            texcoords[x] = toVec2(texcs[j]);
            colors[x] = toVec4(vcolors[j]);
            //texcoords[x].y = 1.0f - texcoords[x].y; 
        }

        vec2 uv = res.uv;
        vec3 nor = res.normal;
        vec3 normal = fma(trinorms[0], vec3(1.0f - uv.x - uv.y), fma(trinorms[1], vec3(uv.x), trinorms[2] * vec3(uv.y)));

        if(length(normal) < 0.0001f) {
            normal = nor;
        } else {
            normal = normalize(normal);
            normal = faceforward(normal, nor, -normal);
        }

        vec2 texcoord = fma(texcoords[0], vec2(1.0f - uv.x - uv.y), fma(texcoords[1], vec2(uv.x), texcoords[2] * vec2(uv.y)));
        vec4 color = fma(colors[0], vec4(1.0f - uv.x - uv.y), fma(colors[1], vec4(uv.x), colors[2] * vec4(uv.y)));
        
        vec3 deltaPos1 = triverts[1] - triverts[0];
        vec3 deltaPos2 = triverts[2] - triverts[0];
        vec2 deltaUV1 = texcoords[1] - texcoords[0];
        vec2 deltaUV2 = texcoords[2] - texcoords[0];
        
        if(all(equal(texcoords[0], texcoords[1])) && all(equal(texcoords[0], texcoords[2]))){
            deltaUV1 = vec2(1.0f, 0.0f);
            deltaUV2 = vec2(0.0f, 1.0f);
        }
        
        float f = 1.0f / fma(deltaUV1.x, deltaUV2.y, -deltaUV1.y * deltaUV2.x);
        vec3 tan = fma(deltaPos1, vec3(deltaUV2.y), -deltaPos2 * deltaUV1.y) * f;

        res.color = color;
        res.normal = normal;
        res.texcoord = texcoord;
        res.materialID = mats[tri];
        res.tangent = normalize(tan - faceforward(normal, tan, -normal));
    }
    
    return res;
}

#include "../hlbvh/traverse.glsl"

layout (local_size_x = RENDERER_CU, local_size_y = 1, local_size_z = 1) in;

void main() {
    int offT = int(gl_GlobalInvocationID.x);
    int it = offT;
    if (it < samplerUniform.rayCount) {
        int t = actived[it];
        Ray ray = fetchRayDirect(t);
        if (ray.actived < 1) return;

        Hit hit = fetchHitDirect(t);
        TResult res = traverse(hit.dist, ray.origin.xyz, ray.direct.xyz);
        if (
            res.dist >= 0.0f && 
            res.dist <= hit.dist && 
            res.dist < INFINITY && 
            res.triangle != LONGEST
        ) {
            Hit newHit = hit;
            newHit.color = res.color;
            newHit.shaded = 0;
            newHit.dist = res.dist;
            newHit.normal.xyz = res.normal;
            newHit.triangle = res.triangle;
            newHit.materialID = res.materialID;
            newHit.texcoord.xy = res.texcoord;
            newHit.tangent.xyz = res.tangent;
            storeHit(t, newHit);
        }
    }
}