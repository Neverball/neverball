#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require


#include "../include/structs.glsl"
#include "../include/constants.glsl"
#include "../include/uniforms.glsl"
#include "../include/fast_math.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"

layout (local_size_x = RENDERER_CU, local_size_y = 1, local_size_z = 1) in;

int part1By1(in int x) {
    x &= 0x0000ffff;
    x = (x | (x <<  8)) & 0x00ff00ff;
    x = (x | (x <<  4)) & 0x0f0f0f0f;
    x = (x | (x <<  2)) & 0x33333333;
    x = (x | (x <<  1)) & 0x55555555;
    return x;
}

int encodeMorton2(in ivec2 xy) {
    return (part1By1(xy.y) << 1) + part1By1(xy.x);
}

void main()
{
    ivec2 wh = ivec2(samplerUniform.sceneRes.xy);
    int offT = int(gl_GlobalInvocationID.x);
    int it = offT;
    
    ivec2 xy = ivec2(it % wh.x, it / wh.x);
    vec2 sceneResInv = 1.0f / vec2(samplerUniform.sceneRes.xy);
    if (xy.x < wh.x && xy.y < wh.y) {
        int idx = int(it);
        int mtk = encodeMorton2(xy);
        globalInvocationSMP = idx;
        
        texelInfo[idx].last = LONGEST;
        texelInfo[idx].count = 0;

        vec2 coord = (vec2(xy) + clamp(vec2(random(), random()), vec2(0.0001f), vec2(0.9999f))) * sceneResInv;
        texelInfo[idx].x = coord.x;
        texelInfo[idx].y = coord.y;
        
        if(cameraUniform.enable360 == 1){
            coord = 1.0f - coord;
        }
        
        float fov_x = PI;
        float fov_y = PI;

        vec4 ray_rot = vec4(0.0f, 0.0f, (mod(coord.x * 2.0f, 1.0f) * fov_x) - fov_x/2, (coord.y * fov_y) - fov_y/2);
        vec4 rot_sin = sin(ray_rot), rot_cos = cos(ray_rot);
        vec4 n = vec4(rot_cos.w * rot_sin.z, -rot_sin.w, rot_cos.w * rot_cos.z, 0.0f);
        vec4 v = vec4(
            n.x*rot_cos.x + n.y*rot_sin.x*rot_sin.y + n.z*rot_sin.x*rot_cos.y,
            n.y*rot_cos.y - n.z*rot_sin.y,
            -n.x*rot_sin.x + n.y*rot_cos.x*rot_sin.y + n.z*rot_cos.x*rot_cos.y,
            0.0f
        );

        vec4 orig;
        vec4 dir;
        
        if(cameraUniform.enable360 == 1){
            orig = cameraUniform.camInv * vec4(0.0f, 0.0f, 0.0f, 1.0f);
            dir = (coord.x > 0.5f ? cameraUniform.camInv : cameraUniform.camInv2) * v;
        } else {
            orig = cameraUniform.camInv * cameraUniform.projInv * vec4(coord * 2.0f - 1.0f, 0.0f, 1.0f);
            orig /= orig.w;
            
            vec4 co = cameraUniform.camInv * cameraUniform.projInv * vec4(coord * 2.0f - 1.0f, 0.999f, 1.0f);
            co /= co.w;
            
            dir = vec4(normalize(co.xyz - orig.xyz), 0.0f);
            
            if(cameraUniform.enable360 == 1){
                
            }
        }

        Ray ray;
        ray.texel = idx;
        ray.prev = LONGEST;
        ray.idx = LONGEST;
        ray.direct = dir;
        ray.origin = orig;
        ray.origin.w = 1.0f;
        ray.actived = 1;
        ray.color = vec4(1.0f);
        ray.final = vec4(0.0f, 0.0f, 0.0f, 1.0f);
        ray.params = ivec4(0);
        ray.extended = ivec4(0);
        ray.params.x = -1;
        ray.params.y = 3;
        ray.params.z = 0; // Show sunlight or not
        ray.params.w = 0;

        //idx += wh.x * wh.y;
        createRay(ray, idx);
    }
}
